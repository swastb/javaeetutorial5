<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<meta name="collection" content="reference">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html">
<META NAME="description" CONTENT="Discusses how to enable a client written in any language supported by CORBA to access Enterprise JavaBeans[tm] components (&quot;EJB<[tm] components&quot;). This paper is directed at programmers with advanced knowledge of both the Java[tm] 2 Platform, Enterprise Edition (&quot;J2EE[tm]&quot;) and CORBA (Common Object Request Broker Architecture).">
<META NAME="keywords" CONTENT="Enterprise JavaBeans, EJB, CORBA clients, RMI-IIOP, Java RMI, Java IDL, IDL,
Interface Definition Language, interoperability">

<TITLE>
 Enterprise JavaBeans[tm] Components and CORBA Clients: A Developer Guide
</TITLE>

</HEAD>
<BODY BGCOLOR="#ffffff">
<BR>
<HR WIDTH=50%>
<BR>
<H1 ALIGN=CENTER>
Enterprise JavaBeans<font size=-1><sup>TM</sup></font> Components and CORBA Clients: A Developer Guide
</H1>
<BR>
<P ALIGN=CENTER><FONT SIZE=-1>
<BR>
<HR WIDTH=50%>
<BR>
<P>
This paper discusses how to enable a client written in any language supported by CORBA to access Enterprise JavaBeans<font size=-1><sup>TM</sup></font> components (&quot;EJB<font size=-1><sup>TM</sup></font> components&quot;). This paper is directed at programmers with advanced knowledge of both the Java<font size=-1><sup>TM</sup></font> 2 Platform, Enterprise Edition (&quot;J2EE<font size=-1><sup>TM</sup></font>&quot;) and CORBA (Common Object Request Broker Architecture). </P>
<P>
<strong>J2EE technology</strong> simplifies enterprise applications by basing them on standardized, modular and re-usable components based on the Enterprise JavaBeans<font size=-1><sup>TM</sup></font> (EJB<font size=-1><sup>TM</sup></font>) architecture, providing a complete set of services to those components, and handling many details of application behavior automatically. By automating many of the time-consuming and difficult tasks of application development, J2EE technology allows enterprise developers to focus on adding value, that is, enhancing business logic, rather than building infrastructure.</P>
<P>
The <strong>EJB<font size=-1><sup>TM</sup></font> server-side component model</strong> simplifies development of middleware components that are transactional, scalable, and portable. Enterprise JavaBeans servers reduce the complexity of developing middleware by providing automatic support for middleware services such as transactions, security, database connectivity, and more.</P>
<P>
<strong>CORBA</strong> is an Object Management Group (OMG) standard that is an open, vendor-independent architecture and infrastructure that computer applications use to work together over networks. Using the standard Internet Inter-ORB Protocol (IIOP), a CORBA-based program from any vendor, on almost any computer, operating system, programming language, and network, can interoperate with a CORBA-based program from the same or another vendor, on almost any other computer, operating system, programming language, and network. To learn more about CORBA, visit <a target="AuxWindow"  href="http://www.omg.org/gettingstarted/gettingstartedindex.htm">http://www.omg.org/gettingstarted/gettingstartedindex.htm</a>.</P>
<P>
<A NAME="pgfId-1000422"></A>CORBA technology complements the Java platform by providing a distributed objects framework, services to support that framework, and interoperability with other languages. CORBA technology is an integral part of the Java 2 platform, being used in Enterprise JavaBeans components, Java Remote Method Invocation APIs running over Internet Inter-ORB Protocol (&quot;Java RMI-IIOP&quot;), and Java IDL APIs (&quot;Java IDL&quot;).</P>
<P>
<A NAME="pgfId-998373"></A>OMG Interface Definition Language (IDL) is used to describe the interfaces being implemented by the remote objects. IDL is used to define the name of the interface and the names of each of the attributes and methods. Once you create the IDL file, you can use an IDL compiler to generate the client stub and the server skeleton in any language for which the OMG has defined a specification for such language mapping. To learn more about OMG IDL, visit <a target="AuxWindow"  href="http://www.omg.org/gettingstarted/omg_idl.htm">http://www.omg.org/gettingstarted/omg_idl.htm</a>.</P>
<P>
<A NAME="pgfId-1000436"></A><strong>Java IDL</strong> makes it possible for distributed Java applications to transparently invoke operations on remote network services using the industry standard OMG IDL and IIOP defined by the Object Management Group (<a target="AuxWindow"  href="http://www.omg.org/">http://www.omg.org</a>). Java RMI over IIOP APIs enable the programming of CORBA servers and applications via the <CODE>
javax.rmi</CODE>
 API. </P>
<P>
<A NAME="pgfId-998262"></A>Developers who program EJB components follow the Java RMI programming model for their distributed object model, where the required transport common across all application servers is Java RMI-IIOP. In heterogeneous server environments, the standard mapping of the EJB architecture to CORBA enables the following interoperability:</P>
<UL>
<LI>
<A NAME="pgfId-998228"></A>A client using an ORB from one vendor can access enterprise beans residing on a server enabled with Enterprise JavaBeans technology (&quot;EJB server&quot;) provided by another vendor.</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-998230"></A>Enterprise beans in one EJB server can access enterprise beans in another EJB server.</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-998232"></A>A CORBA client written in a language other than the Java programming language can access any EJB component as long as there is a mapping from OMG IDL to that programming language.</LI>
</UL>
<P>
<A NAME="pgfId-1000334"></A>The rest of this document provides an example of a CORBA client application accessing an enterprise bean object. In this document, a CORBA client means a client application written in any language supported by CORBA, including the Java programming language, C++, C, Smalltalk, COBOL, Ada, Lisp, or Python. While the Java code in this example is specific to enterprise beans, the process for developing a CORBA client that accesses a server created using the Java RMI-IIOP APIs is the same.</P>
<P>
<A NAME="pgfId-1004703"></A>Links to similar example applications from other vendors who implement J2EE technology can be found in <A HREF="#41577" CLASS="XRef"><em>Links to similar examples</em></A>.</P>
<BR>
<HR WIDTH=50%>
<BR>
<H1>
<A NAME="pgfId-998204"></A>

Developing a CORBA Client that Accesses an Enterprise JavaBean Component</H1>
<P>
<A NAME="pgfId-998322"></A>This is an example of how to develop a CORBA client application that accesses an EJB component. In this example, the client is written in the C++ programming language, but the client could be written in any language supported by CORBA.</P>
<P>
<A NAME="pgfId-998347"></A>The general process for developing a CORBA client so that it can access an enterprise bean is demonstrated in the following sections:</P>
<OL>

<LI><A HREF="#27206" >Write the Enterprise JavaBean component</A></LI>
<LI><A HREF="#31647" >Generate the CORBA IDL</A> </LI>
<LI><A HREF="#64914" >Create a CORBA client</A></LI>
<LI><A HREF="#73772" >Deploy the Enterprise JavaBean component</A> </LI>
<LI><A HREF="#33286" >Run the client executable</A> </LI>
</OL>
<P>
<A NAME="pgfId-996969"></A>This document also includes:</P>
<UL>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997525"></A><A HREF="#23458" >Creating a Java RMI-IIOP client application</A> </LI>
<LI>
<A NAME="pgfId-997515"></A><A HREF="#74676" >Where to go from here</A> </LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997520"></A><A HREF="#15189" >Tips for complex interfaces</A> </LI>

<LI CLASS="Bullet1-">
<A NAME="pgfId-997530"></A><A HREF="#41577" >Links to similar examples</A></LI>
</UL>
<P>
<A NAME="pgfId-998358"></A>In order to make the example simple, we have taken a few shortcuts. For information on building more advanced solutions, see <A HREF="#15189" ><em>Tips for complex interfaces</em></A>.


<OL>
<H2>
<A NAME="pgfId-997537"></A><A NAME="27206"></A>Part I: Write the Enterprise JavaBean component</H2>


<P>
<A NAME="pgfId-996979"></A>The following examples show the code for an enterprise bean that will accept simple <CODE>
String</CODE>
 log messages sent to the application server from Java RMI-IIOP and CORBA clients. The enterprise bean prints them on the server along with the current server time.</P>

<strong><LI>
<A NAME="pgfId-998454"></A>Create the files <CODE>
Logger.java</CODE>
, <CODE>
LoggerHome.java</CODE>
, <CODE>
LoggerEJB.java</CODE>
, and <CODE>
LogMessage.java</CODE>
 in the <CODE>
/Java/src/ejbinterop</CODE>
 directory.</LI></strong>


<A NAME="pgfId-998534"></A>
<H3 CLASS="Head4">
<A NAME="pgfId-1005375"></A>Logger.java</H3>
<P>
<A NAME="pgfId-1005376"></A>The file <CODE>
Logger.java</CODE>
 is the enterprise bean's remote interface, and as such, it extends <CODE>
EJBObject</CODE>
. A remote interface provides the remote client view of an EJB object and defines the business methods callable by a remote client. </P>


<PRE><A NAME="pgfId-996984"></A>
//Code Example 1: Logger.java
package ejbinterop;

import javax.ejb.EJBObject;
import java.rmi.RemoteException;

/**
 * Accepts simple String log messages and prints
 * them on the server.
 */
public interface Logger extends EJBObject
{
    /**
     * Logs the given message on the server with
     * the current server time.
     */
    void logString(String message) throws RemoteException;
}</PRE>



<H3 CLASS="Head4">
<A NAME="pgfId-997002"></A>LoggerHome.java</H3>
<P>
<A NAME="pgfId-1005381"></A>The file <CODE>
LoggerHome.java</CODE>
 extends <CODE>
EJBHome</CODE>
. The <CODE>
EJBHome</CODE>
 interface must be extended by all EJB component's remote home interfaces. A home interface defines the methods that allow a remote client to create, find, and remove EJB objects, as well as home business methods that are not specific to an EJB instance. </P>


<PRE><A NAME="pgfId-997005"></A>
//Code Example 2: LoggerHome.java
package ejbinterop;

import java.rmi.RemoteException;
import javax.ejb.EJBHome;
import javax.ejb.CreateException;

public interface LoggerHome extends EJBHome
{
    Logger create() throws RemoteException, CreateException;
}</PRE>



<H3 CLASS="Head4">
<A NAME="pgfId-997015"></A>LoggerEJB.java</H3>
<P>
<A NAME="pgfId-1005382"></A>The file <CODE>
LoggerEJB.java</CODE>
 contains the code for a session bean. A session bean is an enterprise bean that is created by a client and that usually exists only for the duration of a single client-server session. A session bean performs operations such as calculations or accessing a database for the client. In this example, the enterprise bean accepts simple <CODE>
String</CODE>
 log messages from the client and prints them on the server.</P>


<PRE><A NAME="pgfId-997018"></A>
//LoggerEJB.java
package ejbinterop;

import javax.ejb.*;
import java.util.*;
import java.rmi.*;
import java.io.*;

/**
 * Accepts simple String log messages and prints
 * them on the server.
 */
public class LoggerEJB implements SessionBean {

    public LoggerEJB() {}
    public void ejbCreate() {}
    public void ejbRemove() {}
    public void ejbActivate() {}
    public void ejbPassivate() {}
    public void setSessionContext(SessionContext sc) {}

    /**
     * Logs the given message on the server with
     * the current server time.
     */
    public void logString(String message) {
        LogMessage msg = new LogMessage(message);

        System.out.println(msg);
    }
}</PRE>



<H3 CLASS="Head4">
<A NAME="pgfId-998529"></A>LogMessage.java</H3>
<P>
<A NAME="pgfId-1005383"></A>The file <CODE>
LogMessage.java</CODE>
 takes the current date and time, creates a formatted <CODE>
String</CODE>
 showing the message, and prints the message to the server.</P>

<PRE>
//LogMessage.java
package ejbinterop;

import java.io.Serializable;
import java.util.Date;
import java.text.*;

/**
 * Simple message class that handles pretty
 * printing of log messages.
 */
public class LogMessage implements Serializable
{
    private String message;
    private long datetime;

    /**
     * Constructor taking the message. This will
     * take the current date and time.
     */
    public LogMessage(String msg) {
        message = msg;
        datetime = (new Date()).getTime();
    }

    /**
     * Creates a formatted String showing the message.
     */
    public String toString() {
        StringBuffer sbuf = new StringBuffer();
        DateFormat dformat
            = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,
	DateFormat.LONG);
        FieldPosition fpos = new
            FieldPosition(DateFormat.DATE_FIELD);
        dformat.format(new Date(datetime), sbuf, fpos);
        sbuf.append(&quot;: &quot;);
        sbuf.append(message);
        return sbuf.toString();
    }
}</PRE>

<P>
<A NAME="pgfId-999274"></A>
<LI><strong>Compile the files written in this section, for example,<p></P>

<PRE><A NAME="pgfId-999275"></A>javac -classpath $J2EE_HOME/lib/j2ee.jar:.. *.java</PRE>
</strong><P><strong></strong>
<A NAME="pgfId-1000519"></A>These commands create <CODE>
class</CODE>
 files for all of the <CODE>
.java</CODE>
 files in the current directory. This command and others in this paper assume that the <EM CLASS="Variable">
J2EE_HOME</EM>
 environment variable has been set correctly. Using<EM CLASS="Variable">
 $J2EE_HOME</EM>
 is a convention of the Unix&#174; operating environment. Substitute <EM CLASS="Variable">
%J2EE_HOME%</EM>
 when working in the Microsoft Windows operating environment.</P>

<H2>
<A NAME="pgfId-999277"></A><A NAME="31647"></A>Part II: Generate the CORBA IDL</H2>

<P>
<A NAME="pgfId-999278"></A>This sections discusses generating the Interface Definition Language (IDL) files from the Java class files generated in the previous section. In this example, we will use the <CODE>
rmic</CODE>
 compiler to map the Java code to IDL. IDL provides a purely declarative, programming language-independent way of specifying an object's API. </P>

<P>
<A NAME="pgfId-998675"></A>
<LI><strong>Run the <CODE>
rmic</CODE>
 compiler against the Java class files generated in the previous step as follows:

<PRE><A NAME="pgfId-998678"></A>rmic -idl -noValueMethods -classpath
  $J2EE_HOME/lib/j2ee.jar:&lt;path_to_ejbinterop_dir&gt;
  -d &lt;path_to_where_idl_files_should_be_generated&gt;
  ejbinterop.Logger ejbinterop.LoggerHome
</PRE></strong>
<P>
<A NAME="pgfId-998700"></A>In the preceding example, we are including the JAR file containing definitions for the<CODE>
 javax.ejb</CODE>
 package as well as the directory to our <CODE>
ejbinterop</CODE>
 files. If you're using the Java<font size=-1><sup>TM</sup></font> 2 Platform, Enterprise Edition (J2EE<font size=-1><sup>TM</sup></font>), version 1.3 Reference Implementation (RI), the JAR
 files are located in <CODE>
<em>$J2EE_HOME</em>/lib/j2ee.jar</CODE>
. </P>
<P>
<A NAME="pgfId-998701"></A>In the command line for <CODE>
rmic</CODE>
 above, we recommend a shortcut --<CODE>
 </CODE>
using the<CODE>
 noValueMethods</CODE>
 option. This option tells <CODE>
rmic</CODE>
 to skip any methods with parameter or return types that would be mapped to CORBA value types. The advantage is that it will prevent us from generating a lot of unnecessary IDL that we might have to implement in the C++ client. The disadvantage is that we can only use primitive data types, arrays, and <CODE>
Strings</CODE>
 as parameters or return values, and not our own Java class types. Read more about this in <A HREF="#15189" ><em>Tips for complex interfaces</em></A> </P>
<P>
<A NAME="pgfId-997565"></A>Running the <CODE>
rmic</CODE>
 compiler on the Java class files generates the following files to the directory indicated with the <EM CLASS="Variable">
-d</EM>
 option in the <CODE>
rmic</CODE>
 statement above: </P>
<UL>
<LI>
<A NAME="pgfId-997068"></A><CODE>
java/lang/Ex.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997069"></A><CODE>
java/lang/Exception.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997070"></A><CODE>
java/lang/Object.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997071"></A><CODE>
java/lang/Throwable.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997072"></A><CODE>
java/lang/ThrowableEx.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997073"></A><CODE>
javax/ejb/CreateEx.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997074"></A><CODE>
javax/ejb/CreateException.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997075"></A><CODE>
javax/ejb/EJBHome.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997076"></A><CODE>
javax/ejb/EJBMetaData.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997077"></A><CODE>
javax/ejb/EJBObject.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997078"></A><CODE>
javax/ejb/Handle.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997079"></A><CODE>
javax/ejb/HomeHandle.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997080"></A><CODE>
javax/ejb/RemoveEx.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997081"></A><CODE>
javax/ejb/RemoveException.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997082"></A><CODE>
ejbinterop/Logger.idl </CODE>
</LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-997083"></A><CODE>
ejbinterop/LoggerHome.idl </CODE>
</LI>
</UL>
<P>
<A NAME="pgfId-997578"></A>&nbsp;</P>
<DL>
<DD CLASS="Note">
<A NAME="pgfId-997579"></A></DD>

<STRONG>NOTE: </STRONG>A number of these generated files contain API that can only be used within a Java programming environment. For example, the <CODE>
EJBMetaData</CODE>
 implementation is currently specific to each application server, and thus it will be difficult to develop equivalents that will continue to work over time on platforms other than the Java platform. One option is to remove these from the IDL, but if you do, you'll have to remove them from the IDL every time you change the Java interface and regenerate the IDL files from the <CODE>
rmic</CODE>
 compiler.


</DL>
<DL>
<DD CLASS="Note">
<A NAME="pgfId-997847"></A></DD>


<P>
<STRONG>NOTE: </STRONG>Since CORBA exceptions don't support inheritance, the Java language to IDL mapping creates an <CODE>
Ex</CODE>
 class that contains a CORBA value type representing the actual Java exception. In this basic example, we're not going to worry much about exception support. More information about exceptions can be found at <CODE>
<A target="AuxWindow" HREF="../idl/jidlExceptions.html" CLASS="URL">http://java.sun.com/javase/6/docs/technotes/guides/idl/jidlExceptions.html.</A></CODE>



</DL>
<P>
<LI><strong>
<A NAME="pgfId-998896"></A>Compile the IDL files with your C++ vendor's &quot;IDL to C++&quot; compiler to generate the C++ code corresponding to the IDL. The steps for this procedure vary by vendor, so consult your product documentation for the specific steps for your vendor.</strong><p></P>

<H3>
<A NAME="pgfId-998902"></A><A NAME="64914"></A>Part III: Create a CORBA client</H3>

<P>
<A NAME="pgfId-997094"></A>The client application can be written in any language supported by CORBA. The following example provides the code for a simple C++ client that, given an Object Request Broker (ORB) and a <CODE>
corbaname</CODE>
 URL for a <CODE>
LoggerHome</CODE>
 object, logs a simple <CODE>
String</CODE>
 message on the server. You'll have to adjust the <CODE>
include</CODE>
 statements and modify the code for registering the value factories based on your C++ ORB vendor's libraries. This example was written for ORBacus for C++ 4.0.5 and some of the C++ code in this example is specific to that product.</P>
<P>
<A NAME="pgfId-1000121"></A>A <CODE>
corbaname</CODE>
 URL is a human-readable URL format that enables you to access CORBA objects. It is used to resolve a stringified name from a specific naming context. This is part of the CORBA Interoperable Naming Service (INS). INS is an extension to CORBA Object Services (COS) Naming Service, which was delivered in previous releases of the J2EE platform. To read more about INS, visit <a href="../idl/jidlNaming.html#INS" target="AuxWindow">http://java.sun.com/javase/6/docs/technotes/guides/idl/jidlNaming.html#INS.</a></P>
<P>
<A NAME="pgfId-998739"></A>In this example, the client code does the following:</P>
<UL>
<LI>
<A NAME="pgfId-998741"></A>Creates an Object Request Broker (ORB). The ORB connects objects requesting services to the objects providing them. </LI>

<P>
<LI><A NAME="pgfId-998750"></A>Registers value factories.<p></P>
<P>
<LI><A NAME="pgfId-998751"></A>Looks up the <CODE>
LoggerHome</CODE>
 object in the naming context pointed to by the <CODE>
corbaname</CODE>
 URL.<p></P>
<P>
<LI><A NAME="pgfId-998746"></A>Performs a safe downcast from the object returned to a <CODE>
LoggerHome</CODE>
 object.<p></P>
<P>
<LI><A NAME="pgfId-998747"></A>Creates a <CODE>
LoggerEJB</CODE>
 object reference.<p></P>
<P>
<LI><A NAME="pgfId-998748"></A>Logs our message.<p></P>
<P>
<LI>Tells the application server we won't use this EJB reference again.</LI><p></P>
</UL>
<P>
<LI><strong>
Create the client using C++ code similar to the following. The exact code may vary with your C++ implementation. This code was written for ORBacus for C++ 4.0.5 and some of the C++ code in this example may be specific to that product.<p></P></strong>

<A NAME="pgfId-997590"></A>
<PRE>
//Code Example: Client.cpp
#include &lt;fstream.h&gt;

// C++ ORB Vendor specific include files
// These are from C++ ORBacus 4.0.5

#include &lt;OB/CORBA.h&gt;
#include &lt;OB/OBORB.h&gt;

// Include files generated from our IDL
#include &lt;java/lang/Exception.h&gt;
#include &lt;java/lang/Throwable.h&gt;
#include &lt;javax/ejb/CreateException.h&gt;
#include &lt;javax/ejb/RemoveException.h&gt;
#include &lt;ejbinterop/Logger.h&gt;
#include &lt;ejbinterop/LoggerHome.h&gt;

/**
 * Given an ORB and a corbaname URL for a LoggerHome
 * object, logs a simple string message on the server.
 */
void
run(CORBA::ORB_ptr orb, const char* logger_home_url)
{
  cout &lt;&lt; &quot;Looking for: &quot; &lt;&lt; logger_home_url &lt;&lt; endl;

  // Look up the LoggerHome object in the naming context
  // pointed to by the corbaname URL
  CORBA::Object_var home_obj
    = orb-&gt;string_to_object(logger_home_url);

  // Perform a safe downcast
  ejbinterop::LoggerHome_var home
    = ejbinterop::LoggerHome::_narrow(home_obj.in());

  assert(!CORBA::is_nil(home));

  // Create a Logger EJB reference
  ejbinterop::Logger_var logger = home-&gt;create();

  CORBA::WStringValue_var msg =
    new CORBA::WStringValue((const CORBA::WChar*)L&quot;Message
      from a C++ client&quot;);

  cout &lt;&lt; &quot;Logging...&quot; &lt;&lt; endl;

  // Log our message
  logger-&gt;logString(msg);

  // Tell the application server we won't use this
  // EJB reference any more
  logger-&gt;remove();

  cout &lt;&lt; &quot;Done&quot; &lt;&lt; endl;
}

/**
 * Simple main method that checks arguments, creates an
 * ORB, and handles exceptions.
 */
int
main(int argc, char* argv[])
{
  int exit_code = 0;
  CORBA::ORB_var orb;

  try {

  // Check the arguments
  if (argc != 2) {
    cerr &lt;&lt; &quot;Usage: Client &lt;corbaname URL of LoggerHome&gt;&quot; &lt;&lt; endl;
    return 1;
  }

  // Create an ORB
  orb = CORBA::ORB_init(argc, argv);

  // Register value factories

  // NOTE: This is overkill for the example since we'll never
  // get these exceptions.  Also, the _OB_id method is a
  // proprietary feature of ORBacus C++ generated code.
  CORBA::ValueFactory factory = new java::lang::Throwable_init;
  orb -&gt; register_value_factory(java::lang::Throwable::_OB_id(),
    factory);
  factory -&gt; _remove_ref();

  factory = new java::lang::Exception_init;
  orb -&gt; register_value_factory(java::lang::Exception::_OB_id(),
    factory);
  factory -&gt; _remove_ref();

  factory = new javax::ejb::CreateException_init;
  orb -&gt; 		    register_value_factory(javax::ejb::CreateException::_OB_id(),
      factory);
  factory -&gt; _remove_ref();

  factory = new javax::ejb::RemoveException_init;
  orb -&gt;
    register_value_factory(javax::ejb::RemoveException::_OB_id(),
      factory);
  factory -&gt; _remove_ref();

  // Perform the work
  run(orb, argv[1]);

} catch(const CORBA::Exception&amp; ex) {
  // Handle any CORBA related exceptions
  cerr &lt;&lt; ex._to_string() &lt;&lt; endl;
  exit_code = 1;
}

  // Release any ORB resources
  if (!CORBA::is_nil(orb)) {
    try {
      orb -&gt; destroy();
    } catch(const CORBA::Exception&amp; ex) {
      cerr &lt;&lt; ex._to_string() &lt;&lt; endl;
      exit_code = 1;
    }
  }

  return exit_code;
}</PRE>

<strong><LI>
Use your C++ compiler to compile all of the C++ files, including the Client.cpp file, to create a Client executable. Such tools vary widely across platforms, so consult your product documentation for instructions.</LI></strong>

<H3>
<a name="73772"></a>
<A NAME="pgfId-998921"></A>Part IV: Deploy the Enterprise JavaBean component</H3>

<strong><LI>
Deploy the enterprise bean using your favorite application server. The following steps describe how to deploy the <CODE>
LoggerEJB</CODE>
 component using the J2EE 1.3 Reference Implementation (RI).</LI></strong>
<OL>
<LI>
Start the RI application from a terminal window or command prompt by typing:</LI>

<PRE>	$J2EE_HOME/bin/j2ee -verbose</PRE>

<P>
<LI>When the J2EE 1.3 RI indicates &quot;J2EE server startup complete&quot;, run the deployment tool from another terminal window or command prompt by typing:</LI>

<PRE>	$J2EE_HOME/bin/deploytool</PRE>

<P>
<LI>From the deployment tool, select <CODE>
File</CODE>
 <CODE>
-&gt;</CODE>
 <CODE>
New</CODE>
 <CODE>
-&gt;</CODE>
 <CODE>
Application.</CODE>
<p></P>
<P>
<LI><A NAME="pgfId-997618"></A>In the Application File Name field, enter <CODE>
Logger.ear</CODE>
 to indicate in which file to create the application.<p></P>
<P>
<LI><A NAME="pgfId-997623"></A>In the Application Display Name field, enter <CODE>
Logger</CODE>
 <p></P>
<P>
<LI><A NAME="pgfId-997628"></A>Select OK to save the settings and close this dialog window.<p></P>
<P>
<LI><A NAME="pgfId-997633"></A>From the deployment tool, select <CODE>
File</CODE>
 <CODE>
-&gt;</CODE>
 <CODE>
New</CODE>
 <CODE>
-&gt;</CODE>
 <CODE>
Enterprise Bean.</CODE>
<p></P>
<P>
<LI><A NAME="pgfId-1005451"></A>Select Next if you get the Introduction screen. If not, continue.<p></P>
<P>
<LI><A NAME="pgfId-998943"></A>In the New EnterpriseBean Wizard, select Edit in the Contents box.<p></P>
<P>
<LI><A NAME="pgfId-1005452"></A>Expand the Available Files list, and add the following four <CODE>
.class</CODE>
 files from our <CODE>
ejbinterop</CODE>
 package: <CODE>
Logger.class</CODE>
, <CODE>
LoggerHome.class</CODE>
, <CODE>
LoggerEJB.class</CODE>
, <CODE>
LogMessage.class</CODE>
. Select OK, then Next.<p></P>
<P>
<LI><A NAME="pgfId-997641"></A>Select <CODE>
Stateless</CODE>
 <CODE>
Session</CODE>
 <CODE>
Bean</CODE>
 <CODE>
Type.</CODE>
<p></P>
<P>
<LI><A NAME="pgfId-997646"></A>Select<CODE>
 ejbinterop.LoggerEJB</CODE>
 for the <CODE>
Enterprise</CODE>
 <CODE>
Bean</CODE>
 <CODE>
Class</CODE>
. <p></P>
<P>
<LI><A NAME="pgfId-997650"></A>Select <CODE>
ejbinterop.LoggerHome</CODE>
 for the <CODE>
Remote</CODE>
 <CODE>
Home</CODE>
 <CODE>
Interface</CODE>
.<p></P>
<P>
<LI><A NAME="pgfId-997654"></A>Select <CODE>
ejbinterop.Logger</CODE>
 for the <CODE>
Remote</CODE>
 <CODE>
Interface</CODE>
. <p></P>
<P>
<LI><A NAME="pgfId-997658"></A>Select the Next button until you get to the <CODE>
Security</CODE>
 <CODE>
Settings</CODE>
 page.<p></P>
<P>
<LI><A NAME="pgfId-997662"></A>Select the <CODE>
Deployment</CODE>
 <CODE>
Settings</CODE>
 button<CODE>.</CODE>
<p></P>
<P>
<LI><A NAME="pgfId-997666"></A>Select <CODE>
Support</CODE>
 <CODE>
Client</CODE>
 <CODE>
Choice</CODE>
.<p></P>
<P>
<LI><A NAME="pgfId-997670"></A>Select OK to save the settings and close this dialog window.<p></P>
<P>
<LI><A NAME="pgfId-997674"></A>Select Finish.<p></P>
<P>
<LI><A NAME="pgfId-997678"></A>From the deployment tool, select,<CODE>
 Tools</CODE>
 <CODE>
-&gt;</CODE>
 <CODE>
Deploy.</CODE>
<p></P>
<P>
<LI><A NAME="pgfId-1005453"></A><strong>If running the Java RMI-IIOP client only</strong>, select Return Client JAR.<p></P>
<P>
<LI><A NAME="pgfId-998953"></A>Select Next. <p></P>
<P>
<LI><A NAME="pgfId-997682"></A>Enter <CODE>
ejbinterop/logger</CODE>
 in the <CODE>
JNDI</CODE>
 <CODE>
Name</CODE>
 for our LoggerEJB field.<p></P>
<P>
<LI><A NAME="pgfId-998963"></A>Select Finish.<p></P>
<P>
<LI><A NAME="pgfId-1005772"></A>Select File -&gt; Exit to exit the deploytool.<p></P>
</OL>
<P>
<A NAME="pgfId-997891"></A>Now, the Logger application with our <CODE>
LoggerEJB</CODE>
 components are deployed and ready to receive messages. </P>

<H3>
<A NAME="pgfId-997893"></A><A NAME="33286"></A>Part V: Run the client executable</H3>

<strong><LI>
Run the client executable. One way you can run the client executable is to enter the following URL in a terminal window from the directory containing the executable client file: </LI>

<PRE><A NAME="pgfId-1000172"></A>Client corbaname:iiop:1.2@localhost:1050#ejbinterop/logger</PRE>
</strong>
<P>
<A NAME="pgfId-999091"></A>In this URL,</P>
<UL>
<LI>
<CODE>
Client</CODE>
 is the name of the application to run.</LI>
<P><LI>
<A NAME="pgfId-999094"></A><CODE>
corbaname</CODE>
 specifies that we will resolve a stringified name from a specific naming context. </LI>
<P><LI>
<A NAME="pgfId-999095"></A><CODE>
iiop:1.2</CODE>
 tells the ORB to use the IIOP protocol and GIOP 1.2.</LI>
<P><LI>
<A NAME="pgfId-999096"></A>The host machine on which to find the reference is <CODE>localhost</CODE>, the local machine. To expand this example to run on two machines, enter the IP address
or host name of the machine on which the server is running instead of
 <CODE>localhost</CODE>.</LI>
<P><LI>
<A NAME="pgfId-999098"></A><CODE>
1050</CODE>
 is the port on which the naming service is listening for requests. By default in the J2EE v.1.3 RI, the default port the naming service listens on is port 1050. The portion of the reference up to this point at the hash mark (<CODE>
Client corbaname:iiop:1.2@localhost:1050</CODE>
) is the URL that returns the root naming context.</LI>
<P><LI>
<A NAME="pgfId-1000198"></A><CODE>
ejbinterop/logger</CODE>
 is the name to resolve in the naming context.</LI>
</UL>
<P>
<A NAME="pgfId-999099"></A>If you are using the J2EE 1.3 Reference Implementation, you should see a message similar to the following printed on the application server: </P>
<PRE><A NAME="pgfId-1000207"></A>
Sep 21, 2001 3:33:07 PM PDT: Message from a C++ client<CODE> ejbinterop/
logger</CODE> is the name to be resolved from the Naming Service.
</PRE>

<H3>
<A NAME="pgfId-1005501"></A>Part VI: Stop the J2EE Server</H3>

<strong><LI>
<A NAME="pgfId-1005504"></A>Stop the J2EE server. To stop the server, enter this command in a terminal window or command prompt.</LI>

<PRE><A NAME="pgfId-1005736"></A>$J2EE_HOME/bin/j2ee -stop</PRE>
</strong><P CLASS="StepPara1">
<A NAME="pgfId-1005726"></A>Procedures for stopping running processes vary among operating systems, so if you are running a different server, consult your system documentation for details.</P>

</OL>
<BR>
<HR WIDTH=50%>
<BR>
<H1>
<A NAME="pgfId-997911"></A><A NAME="23458"></A>Creating a Java RMI-IIOP client application</H1>
<P>
<A NAME="pgfId-997310"></A>Using the same example, we can easily develop a Java RMI-IIOP client that connects to an enterprise bean. The differences from the example using a C++ client are:</P>
<UL>
<LI>
<A NAME="pgfId-999143"></A>In your client CLASSPATH, you must include the location of the client JAR
 file created by the J2EE application server running the desired enterprise bean. That JAR
 file contains the necessary client stubs. </LI>
<P><LI>
<A NAME="pgfId-997314"></A>When deploying the application using the J2EE 1.3 RI, check the box <CODE>
Return Client Jar</CODE>
 in the Deploytool on the first page of the Deploy screen. </LI>
</UL>
<P>
<A NAME="pgfId-997316"></A>The following code is the Java RMI-IIOP version of a client for our <CODE>
LoggerEJB</CODE>
 component. Follow the same steps as those presented for the C++ client example. When running the client, use the same URL as in the C++ example. </P>

<UL>
<A NAME="pgfId-997773"></A>
<PRE>
//Code Example: LogClient.java
package ejbinterop;

import java.rmi.RemoteException;
import javax.rmi.*;
import java.io.*;
import javax.naming.*;
import javax.ejb.*;

/**
 * Simple Java RMI-IIOP client that uses an EJB component.
 */
public class LogClient
{
    /**
     * Given a corbaname URL for a LoggerHome,
     * log a simple String message on the server.
     */
    public static void run(String loggerHomeURL)
        throws CreateException, RemoveException,
               RemoteException, NamingException
    {
        System.out.println(&quot;Looking for: &quot; + loggerHomeURL);

        // Create an InitialContext. This will use the
        // CosNaming provider we will specify at runtime.
        InitialContext ic = new InitialContext();

        // Lookup the LoggerHome in the naming context
        // pointed to by the corbaname URL
        Object homeObj = ic.lookup(loggerHomeURL);

        // Perform a safe downcast
        LoggerHome home
            = (LoggerHome)PortableRemoteObject.narrow(homeObj,
	LoggerHome.class);

        // Create a Logger EJB reference
        Logger logger = home.create();

        System.out.println(&quot;Logging...&quot;);

        // Log our message
        logger.logString(&quot;Message from a Java RMI-IIOP client&quot;);

        // Tell the application server we won't use this
        // EJB reference anymore
        logger.remove();

        System.out.println(&quot;Done&quot;);
    }

    /**
     * Simple main method to check arguments and handle
     * exceptions.
     */
    public static void main(String args[])
    {
        try {

            if (args.length != 1) {
                System.out.println(&quot;Args: corbaname URL of LoggerHome&quot;);
                System.exit(1);
            }

            LogClient.run(args[0]);

        } catch (Throwable t) {
            t.printStackTrace();
            System.exit(1);
        }
    }
}</PRE>
</UL>

<H2 CLASS="Head3">
<A NAME="pgfId-1005509"></A>Running the application with the Java RMI-IIOP client</H2>
<P>
<A NAME="pgfId-1005517"></A>When running the example application with a Java RMI-IIOP client instead of a C++ client, follow these steps:</P>
<OL>
<LI>
<A NAME="pgfId-1005518"></A>Compile the .<CODE>
java</CODE>
 files in the <CODE>
ejbinterop</CODE>
/ directory with the following command:</LI>

<PRE><A NAME="pgfId-1005545"></A><CODE>javac -classpath $J2EE_HOME/lib/j2ee.jar:&lt;ejbinterop_directory&gt; *.java</CODE>
</PRE>

<P>
<LI><A NAME="pgfId-1005626"></A>Deploy the Enterprise JavaBean component as described in <A HREF="#73772" ><em>Deploy the Enterprise JavaBean component</em></A>. Remember to select Return Client JAR on the Tools
-&gt; Deploy page when running a Java RMI-IIOP client application. The commands in the Deployment topic
instruct you to start the J2EE RI or other application server.<p></P>
<P>
<LI><A NAME="pgfId-1005537"></A>Run the client application using a command similar to the following:<p></P>

<PRE><A NAME="pgfId-1005538"></A>java -classpath $J2EE_HOME/lib/j2ee.jar:
&lt;path to LoggerClient.jar&gt;/LoggerClient.jar:
&lt;directory_above_ejbinterop&gt;:&lt;ejbinterop_directory&gt;
ejbinterop.LogClient
corbaname:iiop:1.2@localhost:1050#ejbinterop/logger </PRE>
<P>In the window in which the J2EE RI is running, you will see this:</P>
<PRE><A NAME="pgfId-1005828"></A><CODE>Jan 31, 2002 2:27:47 PM PST: Message from a Java RMI-IIOP client</CODE>
</PRE>
<P>In the window from where the client is run, you will see this:
<P>
<PRE><A NAME="pgfId-1005831"></A><CODE>Looking for: corbaname:iiop:1.2@localhost:1050#ejbinterop/logger
Logging...
Done</CODE>
</PRE>

<P>
<LI><A NAME="pgfId-1005539"></A>Stop the J2EE server.<p></P>
</OL>

<BR>
<HR WIDTH=50%>
<BR>


<A NAME="pgfId-1005483"></A>
<H1>
Beyond the Basic Application</H1>
<P>
<A NAME="pgfId-1005484"></A>This section contains the following information:</P>
<UL>
<LI>
<A NAME="pgfId-1005485"></A><A HREF="#74676" >Where to go from here</A></LI>
<LI CLASS="Bullet1-">
<A NAME="pgfId-1005489"></A><A HREF="#15189" >Tips for complex interfaces</A></LI>

<LI CLASS="Bullet1-">
<A NAME="pgfId-1005497"></A><A HREF="#41577" >Links to similar examples</A></LI>
</UL>

<H2>
<A NAME="pgfId-997901"></A><A NAME="74676"></A>Where to go from here</H2>
<P>
<A NAME="pgfId-997902"></A>To enhance the application you could:</P>
<UL>
<LI>
<A NAME="pgfId-999100"></A>Develop the example to use valuetypes. </LI>

<P CLASS="ParaIndent2">
<A NAME="pgfId-999103"></A>To do this, remove the <CODE>
-noValueMethods</CODE>
 switch when you run <CODE>
rmic</CODE>
. Rerun your IDL to C++ language mapping compiler to verify that it supports the valuetypes that have been generated. </P>

<LI>
<A NAME="pgfId-999115"></A>Add another method to <CODE>
Logger</CODE>
 that actually takes a <CODE>
LogMessage</CODE>
. </LI>
</UL>


<H2>
<A NAME="pgfId-997719"></A><A NAME="15189"></A>Tips for complex interfaces</H2>
<P>
<A NAME="pgfId-999118"></A>The interfaces are key to the communication between clients and servers speaking different languages. To increase the probability of success in this area, consider the following suggestions:</P>
<UL>
<LI>
<A NAME="pgfId-997278"></A>Avoid using complex Java classes, such as collections in <CODE>
java.util</CODE>
, for method parameters or return types.</LI>

<P CLASS="ParaIndent2">
<A NAME="pgfId-1004697"></A>After these types are mapped to IDL, you will be forced to implement them in your client programming language. In addition, since Java Object Serialization and RMI-IIOP APIs allow the wire format and internal representation of classes to evolve over time, your CORBA client applications may be incompatible across Java<font size=-1><sup>TM</sup></font> 2 Platform, Standard Edition (J2SE<font size=-1><sup>TM</sup></font>) implementations or versions. </P>

<LI>
<A NAME="pgfId-997294"></A>Start with IDL.</LI>

<P CLASS="ParaIndent2">
<A NAME="pgfId-997296"></A>You may want complex data structures in your return types or method parameters. In this case, try starting with IDL. Define data structures and even exceptions in IDL, and then use them in your EJB interfaces. This will prevent artifacts of the reverse mapping from creeping into your CORBA interfaces. </P>
<P CLASS="ParaIndent2">
<A NAME="pgfId-997300"></A>For instance, try defining the <CODE>
LogMessage</CODE>
 class in IDL initially, and then using the resulting class of a Java language to IDL compilation as a method parameter in the Logger EJB component. </P>

<LI>
<A NAME="pgfId-1000237"></A>Avoid overloading in EJB interfaces.</LI>

<P CLASS="ParaIndent2">
<A NAME="pgfId-1000238"></A>CORBA IDL does not support method overloading, and the Java language to IDL mapping specification handles this by creating IDL method definitions that combine the method name with all its IDL parameter types. This leads to very unfriendly method names for developers using languages other than the Java programming language. </P>

<LI>
<A NAME="pgfId-997303"></A>Consider using bridges.</LI>

<P CLASS="ParaIndent2">
<A NAME="pgfId-999134"></A>If the available options are still too limited or impact the code you wish to write, consider using a server-side bridge. You can read more about constructing such bridges from the sites listed in the links section. </P>
</UL>


<H3>
<A NAME="pgfId-1005512"></A><A NAME="41577"></A>Links to similar examples</H3>
<P>
<A NAME="pgfId-997394"></A>Several vendors implementing J2EE technology have excellent examples and tips for integrating CORBA and Enterprise JavaBeans technology: </P>
<UL>
<LI>
<A NAME="pgfId-997781"></A>IONA - <EM CLASS="Title">
EJB-CORBA and CORBA-EJB Interoperability</EM> at
<A HREF="http://www.iona.com/support/docs/iportal_application_server/3.0/DevelopGuide/html/intro-RMI.html#281858" target="AuxWindow" CLASS="Hypertext">http://www.iona.com/support/docs/iportal_application_server/3.0/DevelopGuide/html/intro-RMI.html#281858</a>.</LI>
<LI>
<A NAME="pgfId-997397"></A>BEA - <EM CLASS="Title">
EJB-to-CORBA/Java Simpapp Sample Application</EM>
 at <A HREF="http://edocs.bea.com/wle/wle50/interop/ejbcorba.htm" target="AuxWindow" CLASS="Hypertext">http://edocs.bea.com/wle/wle50/interop/ejbcorba.htm</a></LI>
<LI>
<A NAME="pgfId-997398"></A>Borland - <EM CLASS="Title">
Sevens steps to build a VisiBroker C++ CORBA Client for an EJB Server</EM>
 at <A HREF="http://www.borland.com/devsupport/appserver/faq/ejbcpp/ejb_cpp.html" target="AuxWindow" CLASS="Hypertext">http://www.borland.com/devsupport/appserver/faq/ejbcpp/ejb_cpp.html</a></LI>
</UL>
<P>
<HR WIDTH=50%>
<A NAME="pgfId-1001052"></A>&nbsp;<p></P>

<P><FONT SIZE=-2>
Copyright &copy; 2002-2004 Sun Microsystems, Inc., 901 San Antonio Road, Palo Alto, California 94303, U.S.A. All rights reserved.

<P>Sun Microsystems, Inc. has intellectual property rights relating to technology embodied in this product. In particular, and without limitation, these intellectual property rights may include one or more of the U.S. patents listed at <a href="http://www.sun.com/patents">http://www.sun.com/patents</a> and one or more additional patents or pending patent applications in the U.S. and other countries.

<P>This product is distributed under licenses restricting its use, copying distribution, and decompilation. No part of this product may be reproduced in any form by any means without prior written authorization of Sun and its licensors, if any.

<P>Third-party software, including font technology, is copyrighted and licensed from Sun suppliers.

<P>Sun,  Sun Microsystems,  the Sun logo,  Java,  Enterprise JavaBeans,  EJB,  J2EE and  Java SE are trademarks or registered trademarks of Sun Microsystems, Inc. in the U.S. and other countries.

<P>UNIX is a registered trademark in the United States and other countries, exclusively licensed through X/Open Company, Ltd.


</FONT>
<HR WIDTH=50%>
<P>


</font></BODY>
</HTML>
